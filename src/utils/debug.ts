import { DebugPrefix } from '@/data/static/app'
import { env } from '@/env'

const isVisible = env.VITE_BETA_FLAG

export enum LogLevel {
  Error = 'error',
  Warn = 'warn',
  Info = 'info',
  Debug = 'debug',
  Default = 'log',
  Time = 'time',
}

const LogLevels: Record<LogLevel, Record<string, string>> = {
  [LogLevel.Error]: {
    title: '🚨',
    background: '#ef4444',
  },
  [LogLevel.Warn]: {
    title: '🔔',
    background: '#fb923c',
  },
  [LogLevel.Info]: {
    title: '👀',
    background: '#10b981',
  },
  [LogLevel.Debug]: {
    title: '🔎',
    background: '#0ea5e9',
  },
  [LogLevel.Default]: {
    title: '🪵',
    background: '#f472b6',
  },
  [LogLevel.Time]: {
    title: '⏱️',
    background: '#f472b6',
  },
}

const OverwriteLevels: Record<LogLevel, LogLevel[]> = {
  [LogLevel.Debug]: [LogLevel.Time],
  [LogLevel.Error]: [],
  [LogLevel.Warn]: [],
  [LogLevel.Info]: [],
  [LogLevel.Default]: [],
  [LogLevel.Time]: [],
}

interface LoggerConfig {
  breakpoint?: string
  level?: LogLevel
  unstyled?: boolean
}

/**
 * @title Debug Logger
 * @description Apply console logger exclusively in development environment
 * @param breakpointComment - Autogenerated with `lg` snippet
 * @param messages
 */
export const logger = (
  { breakpoint, level = LogLevel.Info, unstyled = false }: LoggerConfig,
  ...messages: unknown[]
): void => {
  if (!isVisible) return

  let messageIndex = 0

  // Check if the first parameter is a log level
  if (
    typeof messages[0] === 'string' &&
    Object.values(LogLevel).includes(messages[0] as LogLevel)
  ) {
    level = messages[0] as LogLevel
    messageIndex = 1
  }

  const logLevel = LogLevels[level]

  // mutate level
  for (const key of Object.keys(OverwriteLevels) as LogLevel[]) {
    if (OverwriteLevels[key].includes(level)) {
      level = key
    }
  }

  const css = `
    color: #ffffff;
    background-color: ${logLevel.background ?? '#000000'};
    font-weight: bold;
    padding: 3px;
  `
  const styles: string[] = unstyled
    ? []
    : [css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`]

  const parts = [
    '%c',
    `${DebugPrefix}/${logLevel.title || ''}${level.toUpperCase()}`,
    `%c${breakpoint ?? ''}%c`,
  ]

  const args = [
    ...styles,
    ...messages.slice(messageIndex),
  ] as unknown[] as string[]
  console[level].apply(null, [parts.join(' ')].concat(args))
}

/**
 * A wrapper function for console.time that logs the elapsed time using a custom logger.
 *
 * @param {LoggerConfig} options - Configuration options for the timed logger.
 * @param {string} [options.breakpoint] - An optional breakpoint comment for debugging.
 * @param {LogLevel} [options.level=LogLevel.Time] - The log level to use for the elapsed time message.
 * @param {() => T | Promise<T>} callback - The function to be executed within the timer.
 * @returns {Promise<T>} The result of the callback function.
 * @template T - The return type of the callback function.
 */
export const timedLogger = async <T>(
  { breakpoint, level = LogLevel.Time }: LoggerConfig,

  callback: () => T | Promise<T>,
): Promise<T> => {
  const startTime = performance.now()

  const result = await callback() // Execute the provided function

  const endTime = performance.now()
  const elapsedTime = endTime - startTime

  logger(
    { breakpoint, level },
    `Elapsed time: ${elapsedTime.toFixed(2)} milliseconds`,
  )

  return result
}
